#' Count clonal mutations on one or several chromosomal copies
#'
#' This function counts the number of clonal mutations residing on a single or multiple copies per genomic fragment. Segments of equal copy number and B-allele count are merged per chromosome.
#' @param aceseq.file.name full path to the "comb_pro_extra" file as generated by ACEseq.
#' @param snv.file.name full path to the SNV file as generated by the DKFZ SNV calling pipeline.
#' @param purity.refit should the purity be re-estimated based on the VAF distribution? Defaults to FALSE
#' @param vector of chromosomes to be considered. Defaults to 1-22.
#' @param max.CN highest copy number to take into account. Must not exceed 6.
#' @return a list containing with purity and the overall ploidy of the tumor, clonal.mutation.matrix: a matrix containing the number of clonal mutations per chromosome and state. Rows correspond to copy number/B-allele state, columns correspond to chromosome. Segment.length.matrix: length of the segments as in clonal.mutation.matrix. Copy.number.indicator: the copy number per state (corresponds to rows of clonal.mutation.matrix). B.allele.indicator: the B-allele count per state (corresponds to rows of clonal.mutation.matrix)
#' count.clonal.mutations()

count.clonal.mutations <- function(aceseq.file.name, snv.file.name, purity.refit=F, chromosomes = c(1:22),
                                   max.CN =4){

  if(max.CN>6){
    return("invalid maximal copy number. Choose copy number <= 6")
  }

  ## indicator vectors for the copy numbers and B-allele counts that are to be taken into account
  copy.number.indicator <- c(unlist(sapply(1:max.CN, function(x){rep(x, each=x)})))
  B.allele.indicator <- c(unlist(sapply(1:max.CN, function(x){1:x})))

  ## output: matrices to store the number of mutations at each state and the segment size of each state
  state.df <- data.frame(CN=1:6, name=c("monosomic", "disomic", "trisomic", "tetrasomic", "pentasomic", "hexasomic"))
  state.b <- data.frame(B=1:6, name=c("I", "II", "III", "IV", "V", "VI"))

  clonal.mutation.matrix <- matrix(0, nrow=length(copy.number.indicator), ncol=length(chromosomes),
                                   dimnames = list(apply(rbind(copy.number.indicator, B.allele.indicator), 2, function(x){
                                     state.name <- state.df[state.df$CN==x[1],]$name
                                     state.b <- state.b[state.b$B==x[2],]$name
                                     paste(state.name, state.b, sep="_")
                                   }), paste0("chr", chromosomes)))

  segment.length.matrix <- clonal.mutation.matrix




    ## Read in copy number information as generated by ACEseq:
    copy.number.info. <- read.delim(file=aceseq.file.name, sep="\t", stringsAsFactors = F)

    ## read in the mutation file
    mutations <- read.vcf(snv.file.name)

    ## Extract copy number info for each mutation
    cnv.info.per.mutation <- Extract.copy.number.info.per.SSNV(mutations, copy.number.info.)
    ## obtain the coverage ratios at mutated loci
    coverage.ratios. <- cnv.info.per.mutation$coverage.ratio
    bafs. <- cnv.info.per.mutation$baf
    genotype. <- cnv.info.per.mutation$genotype
    tcn. <- cnv.info.per.mutation$tcn

    ## Extract readcounts of reference and alternative bases
    readcounts. <- Extract.info.from.vcf(mutations, info="readcounts")

    ## Extract ploidy and purity estimates from ACEseq output
    aceseq.file.name. <- strsplit(aceseq.file.name, split="/")[[1]]
    aceseq.file.name. <- aceseq.file.name.[length(aceseq.file.name.)]

    purity. <- Extract.purity.ploidy.from.ACEseq(aceseq.file.name.)$purity
    ploidy. <- Extract.purity.ploidy.from.ACEseq(aceseq.file.name.)$ploidy

    ## re-estimate the purity from the VAF-distribution using normal mixture models
    if(purity.refit==T){
      mixmdl = normalmixEM(readcounts.[!is.na(rowSums(readcounts.)),2]/rowSums(readcounts.[!is.na(rowSums(readcounts.)),]))
      purity. <- max(mixmdl$mu)*2
      while(purity.>1){
        mixmdl = normalmixEM(readcounts.[!is.na(rowSums(readcounts.)),2]/rowSums(readcounts.[!is.na(rowSums(readcounts.)),]))
        purity. <- max(mixmdl$mu)*2
      }
    }

    #######################################################################
    ## Iterate through all autosomes

    for(j in 1:22){

      ## Extract copy number info etc. for the current chromosome
      copy.number.info <- copy.number.info.[copy.number.info.$X.chromosome==j,,drop=F]
      if(nrow(copy.number.info)==0){next}
      bafs <- bafs.[which(mutations$vcf$CHROM==j)]
      if(length(bafs)==0){next}
      coverage.ratios <- coverage.ratios.[which(mutations$vcf$CHROM==j)]
      tcn <- tcn.[which(mutations$vcf$CHROM==j)]
      genotype <- genotype.[which(mutations$vcf$CHROM==j)]
      if(length(coverage.ratios)==0){next}
      readcounts <- readcounts.[which(mutations$vcf$CHROM==j),,drop=F]
      if(nrow(readcounts)==0){next}

      #######################################################################
      ## Iterate through all copy number states

      for(k in unique(copy.number.indicator)){


        #######################################################################
        ## Iterate through all A/B combinations and determine the number of mutations in the clonal peaks.
        ## In regions that are monosomic or disomic there is only one clonal peak, which does not carry much information.
        ## However, in higher orders, we can use the number of mutations on more than one allele as a surrogate for the time that has passed since conception
        ## and the amplification event.
        ## We fit all clonal peaks (for the lower-order peak only the right hand side to avoid contamination with subclonal mutations) to the sum of two binomials in dependence of the number of mutations belonging to
        ## each peak.

        for(l in B.allele.indicator[which(copy.number.indicator==k)][ceiling(length(B.allele.indicator[which(copy.number.indicator==k)])/2):
                                                                     length(B.allele.indicator[which(copy.number.indicator==k)])]){


          ## Frequency of the clonal peak associated with mutations on monosomic chromosomes
          monosomic.prob.clonal <- purity./(purity.*k + (1-purity.)*2)

          ## Expected frequencies of lower- and higher-order clonal peaks
          clonal.peaks <- sort(unique(sapply(c(1, l, k-l), function(x){x*purity./(purity.*k + (1-purity.)*2)})))
          clonal.peaks <- clonal.peaks[clonal.peaks!=0]

          ## Assign regions to a specific copy number with tolerance +/- 0.1 from expected coverage ratio
          expected.coverage.ratio <- (k*purity. + (1-purity.)*2)/(ploidy.*purity.+(1-purity.)*2)
          segment.length.matrix[which(copy.number.indicator==k & B.allele.indicator %in% c(k-l,l)),j] <-  segment.length.matrix[which(copy.number.indicator==k & B.allele.indicator %in% c(k-l,l)),j] +
            rep(sum(as.numeric(copy.number.info[((copy.number.info$tcnMeanRaw>(expected.coverage.ratio-0.1) & copy.number.info$tcnMeanRaw<(expected.coverage.ratio+0.1))|
                                                   (as.numeric(copy.number.info$TCN)==k & !is.na(as.numeric(copy.number.info$TCN))) ) &
                                                  (((copy.number.info$BAF < (max(l/k, 1-l/k)+0.05) & copy.number.info$BAF > (max(l/k, 1-l/k)-0.05)) &
                                                      !is.na(copy.number.info$BAF) | (is.na(copy.number.info$BAF) & l==k/2)) |
                                                     ((copy.number.info$genotype==paste(k-l, l, sep=":") | copy.number.info$genotype==paste(l, k-l, sep=":")) &
                                                        !is.na(copy.number.info$genotype))),]$end)-
                      as.numeric(copy.number.info[((copy.number.info$tcnMeanRaw>(expected.coverage.ratio-0.1) & copy.number.info$tcnMeanRaw<(expected.coverage.ratio+0.1))|
                                                     (as.numeric(copy.number.info$TCN)==k & !is.na(as.numeric(copy.number.info$TCN))) ) &
                                                    (((copy.number.info$BAF < (max(l/k, 1-l/k)+0.05) & copy.number.info$BAF > (max(l/k, 1-l/k)-0.05)) &
                                                        !is.na(copy.number.info$BAF) | (is.na(copy.number.info$BAF) & l==k/2)) |
                                                       ((copy.number.info$genotype==paste(k-l, l, sep=":") | copy.number.info$genotype==paste(l, k-l, sep=":")) &
                                                          !is.na(copy.number.info$genotype))),]$start)), ifelse(k==l, 1, length(unique(c(l, k-l)))))




          ## the monosomic fraction is putatively measured for several states, thus add up
          if(l!=1 & (k-l)!=1){
            segment.length.matrix[which(copy.number.indicator==k & B.allele.indicator==1),j] <- segment.length.matrix[which(copy.number.indicator==k & B.allele.indicator==1),j] +
              sum(as.numeric(copy.number.info[((copy.number.info$tcnMeanRaw>(expected.coverage.ratio-0.1) & copy.number.info$tcnMeanRaw<(expected.coverage.ratio+0.1))|
                                                 (as.numeric(copy.number.info$TCN)==k & !is.na(as.numeric(copy.number.info$TCN))) ) &
                                                (((copy.number.info$BAF < (max(l/k, 1-l/k)+0.05) & copy.number.info$BAF > (max(l/k, 1-l/k)-0.05)) &
                                                    !is.na(copy.number.info$BAF) | (is.na(copy.number.info$BAF) & l==k/2)) |
                                                   ((copy.number.info$genotype==paste(k-l, l, sep=":") | copy.number.info$genotype==paste(l, k-l, sep=":")) &
                                                      !is.na(copy.number.info$genotype))),]$end)-
                    as.numeric(copy.number.info[((copy.number.info$tcnMeanRaw>(expected.coverage.ratio-0.1) & copy.number.info$tcnMeanRaw<(expected.coverage.ratio+0.1))|
                                                   (as.numeric(copy.number.info$TCN)==k & !is.na(as.numeric(copy.number.info$TCN))) ) &
                                                  (((copy.number.info$BAF < (max(l/k, 1-l/k)+0.05) & copy.number.info$BAF > (max(l/k, 1-l/k)-0.05)) &
                                                      !is.na(copy.number.info$BAF) | (is.na(copy.number.info$BAF) & l==k/2)) |
                                                     ((copy.number.info$genotype==paste(k-l, l, sep=":") | copy.number.info$genotype==paste(l, k-l, sep=":")) &
                                                        !is.na(copy.number.info$genotype))),]$start))


          }

          ## If the current copy number state does not exist on the present autosome, continue
          if(segment.length.matrix[which(copy.number.indicator==k & B.allele.indicator==l),j]==0){next}

          ## Count the number of mutations that lie on the respective copy numbers
          ## 1st: choose all mutations that lie on loci with current copy number
          mutations.at.copy.number <-  readcounts[((coverage.ratios>(expected.coverage.ratio-0.1) & coverage.ratios < (expected.coverage.ratio+0.1) & !is.na(coverage.ratios)) |
                                                     tcn==k & !is.na(tcn)) &
                                                    (((bafs < (max(l/k, 1-l/k)+0.05) & bafs > (max(l/k, 1-l/k)-0.05)) & !is.na(bafs) | (is.na(bafs) & l==k/2)) |
                                                       genotype==paste(k-l, l, sep=":") | genotype==paste(l, k-l, sep=":")),,drop=F]

          if(nrow(mutations.at.copy.number)==0){next}


          ## 2nd we now count all mutations that lie on the right hand side of the monosomic clonal peak to remove subclonal mutations

          mutations.at.copy.number <- mutations.at.copy.number[mutations.at.copy.number[,2]/rowSums(mutations.at.copy.number)>=monosomic.prob.clonal,,drop=F]
          mutations.at.copy.number <- mutations.at.copy.number[!is.na(rowSums(mutations.at.copy.number)),,drop=F]

          if(nrow(mutations.at.copy.number)==0){next}

          ## If there's only one mutation, assign it to its most likely state by comparing its VAF with the clonal frequencies
          if(nrow(mutations.at.copy.number) == 1){
            which.peak <- which.min(c(clonal.peaks - mutations.at.copy.number[,2]/rowSums(mutations.at.copy.number))^2)
            which.peak <- c(1, sort(c(l, k-l)))[which.peak]

            clonal.mutation.matrix[which(copy.number.indicator==k & B.allele.indicator==which.peak),j] <- 1
            next
          }

          ## In case of monosomic or heterozygous disomic regions, there is only one clonal peak. Thus  assign all mutations to that peak
          if(k %in% c(1,2) & l==1){
            clonal.mutation.matrix[which(copy.number.indicator==k & B.allele.indicator==l),j] <- nrow(mutations.at.copy.number)
            next}


          ## For the remaining cases, estimate the sizes of the clonal peaks using a binomial mixture model.
          ## Define the posterior probability of a mixing model with mixing factor p. Scan p over 0 - 1 and select the most likely one.

          p.priors <- seq(0, 1, 0.01)
          posteriors <- sapply(p.priors, function(p){
            sum(apply(mutations.at.copy.number, 1, function(x){
              L <-  dbinom(x = x[2], size=sum(x), prob = clonal.peaks)
              P <- L/sum(L)
              log(sum(c(p, rep(1-p, length(clonal.peaks) - 1))*P))
            }))
          })


          clonal.mutation.matrix[which(copy.number.indicator==k & B.allele.indicator %in% c(1, l, k-l)),j] <- c(nrow(mutations.at.copy.number)*p.priors[which.max(posteriors)],
                                                                                                                     rep(nrow(mutations.at.copy.number)*(1-p.priors[which.max(posteriors)]),
                                                                                                                         length(clonal.peaks)-1)) +
            clonal.mutation.matrix[which(copy.number.indicator==k & B.allele.indicator %in% c(1, l, k-l)),j]


        }
      }
      ## The lower-order clonal peak was only quantified on its RHS. Thus multiply by 2.
      clonal.mutation.matrix[,j] <- clonal.mutation.matrix[,j]*replace(rep(1, length(clonal.mutation.matrix[,j])),
                                                                         which(B.allele.indicator==1),2)
    }


    return(list(purity = purity., ploidy = ploidy., clonal.mutation.matrix = clonal.mutation.matrix, segment.length.matrix = segment.length.matrix,
                copy.number.indicator = copy.number.indicator, B.allele.indicator = B.allele.indicator))

}
